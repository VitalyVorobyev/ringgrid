//! Marker ID decoding from ring sector patterns.
//!
//! Each marker encodes a unique ID via 16 binary sectors (black/white)
//! in the annular band between the inner and outer ring edges. Decoding:
//!
//! 1. Sample pixel intensities along an elliptical arc in the code band.
//! 2. Threshold into a 16-bit binary word.
//! 3. Match against the embedded codebook, trying all 16 cyclic rotations
//!    and selecting the best by Hamming distance with margin.
//!
//! The codebook is generated by `tools/gen_codebook.py` and embedded as
//! compile-time constants in `codebook.rs`.

use crate::codebook::{CODEBOOK, CODEBOOK_BITS, CODEBOOK_N};

// ── Bit manipulation helpers ───────────────────────────────────────────

/// Count set bits (popcount).
#[inline]
fn popcount(x: u16) -> u8 {
    x.count_ones() as u8
}

/// Cyclic left rotation of a 16-bit word by `k` positions.
#[inline]
pub fn rotate_left_16(word: u16, k: u32) -> u16 {
    let k = k % 16;
    if k == 0 {
        word
    } else {
        (word << k) | (word >> (16 - k))
    }
}

/// Return the canonical form (minimum over all cyclic rotations).
pub fn canonical_16(word: u16) -> u16 {
    (0..16).map(|k| rotate_left_16(word, k)).min().unwrap()
}

// ── Codebook wrapper ───────────────────────────────────────────────────

/// An embedded codebook for marker ID matching.
pub struct Codebook {
    words: &'static [u16],
}

impl Default for Codebook {
    fn default() -> Self {
        Self {
            words: &CODEBOOK[..CODEBOOK_N],
        }
    }
}

/// Result of matching an observed word against the codebook.
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Match {
    /// Index into the codebook (marker ID).
    pub id: usize,
    /// Cyclic rotation that produced the best match (0..15).
    pub rotation: u8,
    /// Hamming distance to the best-matching codeword (after rotation).
    pub dist: u8,
    /// Margin: second_best_dist − best_dist.
    pub margin: u8,
    /// Confidence heuristic in [0, 1].
    pub confidence: f32,
}

impl Codebook {
    /// Create a codebook from a static slice of codewords.
    pub fn new(words: &'static [u16]) -> Self {
        Self { words }
    }

    /// Number of codewords.
    pub fn len(&self) -> usize {
        self.words.len()
    }

    /// Whether the codebook is empty.
    pub fn is_empty(&self) -> bool {
        self.words.is_empty()
    }

    /// Get the codeword for a given marker ID.
    pub fn word(&self, id: usize) -> Option<u16> {
        self.words.get(id).copied()
    }

    /// Match an observed 16-bit word against the codebook.
    ///
    /// Tries all 16 cyclic rotations of each codeword and returns the
    /// best match. Confidence combines distance and margin:
    ///   confidence = clamp(1 − dist/6) * clamp(margin/3)
    pub fn match_word(&self, obs: u16) -> Match {
        let mut best_id = 0usize;
        let mut best_rot = 0u8;
        let mut best_dist = u8::MAX;
        let mut second_dist = u8::MAX;

        for (id, &cw) in self.words.iter().enumerate() {
            for k in 0u32..CODEBOOK_BITS as u32 {
                let rotated = rotate_left_16(cw, k);
                let d = popcount(obs ^ rotated);
                if d < best_dist {
                    second_dist = best_dist;
                    best_dist = d;
                    best_id = id;
                    best_rot = k as u8;
                } else if d < second_dist {
                    second_dist = d;
                }
            }
        }

        let margin = second_dist.saturating_sub(best_dist);
        let conf_dist = (1.0 - best_dist as f32 / 6.0).clamp(0.0, 1.0);
        let conf_margin = (margin as f32 / 3.0).clamp(0.0, 1.0);
        let confidence = conf_dist * conf_margin;

        Match {
            id: best_id,
            rotation: best_rot,
            dist: best_dist,
            margin,
            confidence,
        }
    }
}

/// Decode a marker ID from the image around a detected marker.
///
/// TODO Milestone 4: implement sector sampling and thresholding.
/// For now, returns None.
pub fn decode_marker_id(
    _image: &image::GrayImage,
    _outer_ellipse: &crate::conic::Ellipse,
    _inner_ratio: f64,
) -> Option<u32> {
    // TODO Milestone 4: implement sector sampling along elliptical arcs,
    // adaptive thresholding, then call Codebook::default().match_word()
    None
}

// ── Tests ──────────────────────────────────────────────────────────────

#[cfg(test)]
mod tests {
    use super::*;
    use crate::codebook::CODEBOOK_MIN_CYCLIC_DIST;
    use rand::prelude::*;

    #[test]
    fn test_no_codeword_is_rotationally_symmetric() {
        for (i, &w) in CODEBOOK.iter().enumerate() {
            for k in 1u32..16 {
                assert_ne!(
                    rotate_left_16(w, k),
                    w,
                    "codeword {} (0x{:04X}) is rotationally symmetric at k={}",
                    i, w, k
                );
            }
        }
    }

    #[test]
    fn test_pairwise_uniqueness_under_rotation() {
        // Check that no two codewords share a rotation
        let n = CODEBOOK.len();
        // For speed, sample pairs if codebook is large
        let mut rng = StdRng::seed_from_u64(42);
        let pairs_to_check = 50_000.min(n * (n - 1) / 2);

        for _ in 0..pairs_to_check {
            let i = rng.gen_range(0..n);
            let j = rng.gen_range(0..n);
            if i == j {
                continue;
            }
            let wi = CODEBOOK[i];
            let wj = CODEBOOK[j];
            for k in 0u32..16 {
                assert_ne!(
                    rotate_left_16(wi, k),
                    wj,
                    "codeword {} and {} collide under rotation {}",
                    i, j, k
                );
            }
        }
    }

    #[test]
    fn test_pairwise_min_cyclic_distance() {
        // Verify a sample of pairs meets the claimed minimum distance
        let n = CODEBOOK.len();
        let mut rng = StdRng::seed_from_u64(123);
        let pairs = 20_000.min(n * (n - 1) / 2);
        let mut observed_min = 16u8;

        for _ in 0..pairs {
            let i = rng.gen_range(0..n);
            let j = rng.gen_range(0..n);
            if i == j {
                continue;
            }
            let d = (0u32..16)
                .map(|k| popcount(CODEBOOK[i] ^ rotate_left_16(CODEBOOK[j], k)))
                .min()
                .unwrap();
            if d < observed_min {
                observed_min = d;
            }
        }

        assert!(
            observed_min >= CODEBOOK_MIN_CYCLIC_DIST as u8,
            "observed min cyclic dist {} < claimed {}",
            observed_min, CODEBOOK_MIN_CYCLIC_DIST
        );
    }

    #[test]
    fn test_exact_match() {
        let cb = Codebook::default();
        // Every codeword should match itself exactly
        for id in 0..cb.len().min(100) {
            let w = cb.word(id).unwrap();
            let m = cb.match_word(w);
            assert_eq!(m.id, id, "exact match failed for id {}", id);
            assert_eq!(m.dist, 0);
            assert_eq!(m.rotation, 0);
        }
    }

    #[test]
    fn test_match_with_rotation() {
        let cb = Codebook::default();
        let mut rng = StdRng::seed_from_u64(77);
        for _ in 0..100 {
            let id = rng.gen_range(0..cb.len());
            let w = cb.word(id).unwrap();
            let rot = rng.gen_range(0u32..16);
            let rotated = rotate_left_16(w, rot);
            let m = cb.match_word(rotated);
            assert_eq!(m.id, id, "rotation match failed for id {} rot {}", id, rot);
            assert_eq!(m.dist, 0);
        }
    }

    #[test]
    fn test_match_with_1_bit_flip() {
        // With min_cyclic_dist=2, a 1-bit flip guarantees the corrupted word
        // is closer to the true codeword (dist=1) than to any other (dist>=2).
        // However, another codeword *rotated* might also be at dist=1.
        // So we check that the best match distance is 1 and that most decode
        // correctly.
        let cb = Codebook::default();
        let mut rng = StdRng::seed_from_u64(99);
        let mut correct = 0;
        let total = 200;

        for _ in 0..total {
            let id = rng.gen_range(0..cb.len());
            let w = cb.word(id).unwrap();
            let rot = rng.gen_range(0u32..16);
            let mut obs = rotate_left_16(w, rot);

            let bit = rng.gen_range(0..16);
            obs ^= 1u16 << bit;

            let m = cb.match_word(obs);
            assert!(m.dist <= 1, "1-bit flip should give dist <= 1, got {}", m.dist);
            if m.id == id {
                correct += 1;
            }
        }

        let rate = correct as f64 / total as f64;
        eprintln!("1-bit flip correct rate: {:.1}%", rate * 100.0);
        // With min_cyclic_dist=2, 1-bit error correction is not guaranteed.
        // We just verify the machinery doesn't panic and returns dist <= 1.
    }

    #[test]
    fn test_match_with_2_bit_flips() {
        // With min_cyclic_dist=2, 2-bit flips can land on another codeword
        // (dist=2 = min_dist). We just verify no panics and report the rate.
        let cb = Codebook::default();
        let mut rng = StdRng::seed_from_u64(2024);
        let mut correct = 0;
        let total = 200;

        for _ in 0..total {
            let id = rng.gen_range(0..cb.len());
            let w = cb.word(id).unwrap();
            let rot = rng.gen_range(0u32..16);
            let mut obs = rotate_left_16(w, rot);

            let bit1 = rng.gen_range(0u16..16);
            let mut bit2 = rng.gen_range(0u16..15);
            if bit2 >= bit1 {
                bit2 += 1;
            }
            obs ^= (1u16 << bit1) | (1u16 << bit2);

            let m = cb.match_word(obs);
            assert!(m.dist <= 2, "2-bit flip should give dist <= 2, got {}", m.dist);
            if m.id == id {
                correct += 1;
            }
        }

        // Just log the rate; with dist=2, 2-bit flips are at the correction limit
        let rate = correct as f64 / total as f64;
        eprintln!("2-bit flip correct rate: {:.1}%", rate * 100.0);
        // No hard assertion on rate — this is informational
    }

    #[test]
    fn test_confidence_heuristic() {
        let cb = Codebook::default();
        let w = cb.word(0).unwrap();

        // Exact match: high confidence
        let m = cb.match_word(w);
        assert!(m.confidence > 0.0, "exact match should have positive confidence");

        // Far-away word (all bits flipped): low distance to complement
        let flipped = !w;
        let m2 = cb.match_word(flipped);
        // The complement might match some other codeword well, but generally
        // with large distance the confidence should be lower
        let _ = m2; // just ensure no panic
    }

    #[test]
    fn test_canonical() {
        assert_eq!(canonical_16(0x0001), 0x0001);
        assert_eq!(canonical_16(0x8000), 0x0001); // rotation of 0x0001
        assert_eq!(canonical_16(0x0003), 0x0003);
        assert_eq!(canonical_16(0xC000), 0x0003); // rotation of 0x0003
    }
}
