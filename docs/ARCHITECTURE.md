# ringgrid Architecture

## Overview

ringgrid detects circle/ring-based calibration targets in images from
Scheimpflug cameras where strong, anisotropic defocus blur is present.
Typical conditions: marker outer diameter ~20 px, blur kernel scale ~10 px.

### Board Design

- **Dense HEX (triangular) lattice** with axial coordinates (q, r).
  Pointy-top orientation: `x = pitch * (√3*q + √3/2*r)`, `y = pitch * 3/2*r`.
- **Two-edge ring markers**: each marker has an inner and outer ring edge,
  providing two concentric ellipses for robust center estimation.
- **All markers are coded**: 16 binary sectors in the annular band between
  inner and outer rings encode a unique ID per marker.
- **Codebook**: ~893 codewords, 16 bits each, selected for rotational
  uniqueness and maximized cyclic Hamming distance (min distance = 2).
  Generated by `tools/gen_codebook.py`, embedded as compile-time constants.

### Decoding Strategy

Each observed 16-bit word is matched against the codebook by trying all
16 cyclic rotations and selecting the best match by Hamming distance.
Confidence combines distance and margin:
`confidence = clamp(1 - dist/6) * clamp(margin/3)`.

## Pipeline Stages

```
Image → Preprocess → Edges → Conic Fit → Lattice → Refine → Codec → Output
```

### 1. Preprocess (`core::preprocess`)

- **Illumination normalization**: subtract local-mean background to handle
  uneven illumination across the field (common in Scheimpflug setups where
  the focal plane is tilted).
- **Band-pass filtering**: DoG or LoG tuned to the expected ring spatial
  frequency, suppressing both low-frequency shading and high-frequency noise.

### 2. Edge Detection (`core::edges`)

- Gradient computation (Sobel/Scharr) followed by non-maximum suppression.
- Hysteresis thresholding for connected edge segments.
- **Sub-pixel refinement** via parabolic interpolation of gradient magnitude
  perpendicular to the edge direction.
- Edge points are grouped into candidate arcs for ellipse fitting.

### 3. Conic / Ellipse Fitting (`core::conic`)

- **Direct least-squares conic fit** (Fitzgibbon et al., 1999): solves a
  constrained eigenvalue problem enforcing the ellipse condition B²−4AC < 0.
- Custom 3×3 generalized eigenvalue solver (cubic polynomial + adjugate
  null vector) to avoid issues with non-symmetric matrix eigendecomposition.
- **RANSAC wrapper** for outlier-robust fitting: samples 6-point minimal
  subsets, scores by inlier count under **Sampson distance** (first-order
  geometric distance approximation, threshold in pixels).
- Early exit when >90% of points are inliers.
- Point normalization (centroid shift + isotropic scaling to mean distance √2)
  for numerical stability.
- Error handling via `ConicError` enum with variants: `TooFewPoints`,
  `DegenerateConic`, `NotAnEllipse`, `NumericalFailure`, `InsufficientInliers`.
- Utilities: conic ↔ ellipse conversion, algebraic/Sampson residuals,
  validity checks.

### 4. Lattice / Grid Analysis (`core::lattice`)

- Build a nearest-neighbor graph from detected ellipse centers.
- Extract two dominant grid directions from the neighbor displacement vectors.
- Estimate **vanishing points** for each grid direction.
- Compute the **vanishing line** as the join of the two vanishing points.

#### Why affine rectification for center bias

Under perspective projection, the image of a circle is an ellipse, but the
ellipse center does **not** coincide with the projection of the circle's 3D
center. This systematic error is called *center bias* or *eccentricity error*
and can reach several pixels for markers near the image periphery under
strong perspective.

The key insight is that center bias arises from the **projective** (as opposed
to affine) component of the projection. If we can remove the projective
component — i.e., perform an **affine rectification** — then ellipse centers
become unbiased estimates of the projected circle centers.

The affine rectification homography is:

```
H = [ 1  0  0 ]
    [ 0  1  0 ]
    [ l₁ l₂ l₃]
```

where **l** = (l₁, l₂, l₃) is the vanishing line. This H maps the vanishing
line back to the line at infinity, removing the projective distortion.

After rectification, per-marker refinement proceeds in affine-rectified
coordinates, and the final centers are mapped back to the original image
frame.

### 5. Refinement (`core::refine`)

- **Shared-center dual-ring model**: each marker has two concentric circles
  (inner/outer ring) that project to two ellipses sharing the same center
  (in rectified space).
- Levenberg–Marquardt minimization of robust (Huber/Tukey) geometric
  residuals from edge points to the nearest ring boundary.
- Covariance estimation for uncertainty propagation.

### 6. Codec (`core::codec`)

- Each marker encodes a unique ID via 16 binary sectors (black/white)
  in the annular band between the inner and outer ring edges.
- Intensity sampling along elliptical arcs, adaptive thresholding.
- Match against embedded codebook trying all 16 cyclic rotations,
  selecting best by Hamming distance with margin-based confidence.
- Embedded codebook generated by `tools/gen_codebook.py` (893 codewords,
  min cyclic Hamming distance 2).

## Crate Structure

```
crates/
  ringgrid-core/    # All algorithms, no I/O beyond image loading
  ringgrid-cli/     # CLI interface: load image, run pipeline, write JSON
                    # Binary name: ringgrid
tools/
  gen_codebook.py   # Codebook generation (greedy + random restart)
  gen_synth.py      # Synthetic dataset generation (hex lattice + homography)
  viz_debug.py      # Debug visualization (matplotlib overlay)
  score_run.py      # Scoring / evaluation harness (stub)
  codebook.json     # Generated codebook (893 codewords)
docs/
  ARCHITECTURE.md   # This file
```

## CLI Subcommands

- `ringgrid detect --image <path> --out <path> [--debug <path>]` — run
  detection pipeline, write results JSON and optional debug JSON.
- `ringgrid codebook-info` — print embedded codebook statistics.
- `ringgrid decode-test --word 0xABCD` — decode a 16-bit word against
  the embedded codebook (for development/debugging).

## Detection Output Schema

```json
{
  "detected_markers": [
    {
      "center_xy": [x, y],
      "ellipse_params": { "semi_axes": [a, b], "angle": theta },
      "id": 42,
      "confidence": 0.85,
      "debug": {
        "outer_edge_count": 120,
        "inner_edge_count": 80,
        "outer_fit_rms": 0.45,
        "inner_fit_rms": 0.38,
        "raw_word": 1234,
        "codec_dist": 0,
        "codec_margin": 3
      }
    }
  ],
  "image_size": [width, height]
}
```

Optional fields (`ellipse_params`, `id`, `confidence`, `debug`) are omitted
from JSON output when not available (e.g., before the codec stage is
implemented).

## Milestones

- **M0** ✓: Workspace setup, conic fitting primitives, CLI skeleton.
- **M1** ✓: Rename to ringgrid. Codebook generator + Rust codec matcher.
  Synthetic dataset generator. Hardened conic fitting. CLI helpers.
- **M2**: Edge detection, full detection pipeline, lattice analysis.
- **M3**: Per-marker refinement (LM), dual-ring model.
- **M4**: Codec sector sampling and decoding from images.
- **M5**: Performance optimization, benchmarks, documentation.
