#!/usr/bin/env python3
"""Generate board specification: JSON + embedded Rust module.

Produces:
  1. tools/board/board_spec.json  — canonical board layout
  2. crates/ringgrid-core/src/board_spec.rs — embedded Rust constants

Usage:
    python tools/gen_board_spec.py
    python tools/gen_board_spec.py --pitch_mm 8.0 --board_mm 200.0
"""

import argparse
import json
import math
from pathlib import Path


def hex_axial_to_xy(q: int, r: int, pitch: float) -> tuple[float, float]:
    """Pointy-top hex: (q,r) -> (x,y) mm."""
    x = pitch * (math.sqrt(3) * q + math.sqrt(3) / 2 * r)
    y = pitch * 1.5 * r
    return x, y


def generate_hex_lattice(
    board_mm: float, pitch_mm: float
) -> list[tuple[int, int, float, float]]:
    """Generate hex lattice within board bounds. Returns (q, r, x_mm, y_mm)."""
    half = board_mm / 2.0
    max_coord = int(half / pitch_mm) + 2
    points = []
    for q in range(-max_coord, max_coord + 1):
        for r in range(-max_coord, max_coord + 1):
            x, y = hex_axial_to_xy(q, r, pitch_mm)
            margin = pitch_mm * 0.6
            if abs(x) < half - margin and abs(y) < half - margin:
                points.append((q, r, x, y))
    points.sort(key=lambda p: (p[1], p[0]))
    return points


def write_json(path: Path, spec: dict) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with open(path, "w") as f:
        json.dump(spec, f, indent=2)
    print(f"Board spec JSON written to {path} ({spec['n_markers']} markers)")


def write_rust(path: Path, spec: dict) -> None:
    n = spec["n_markers"]
    markers = spec["markers"]
    pitch = spec["pitch_mm"]
    board = spec["board_size_mm"][0]
    outer_r = spec.get("marker_outer_radius_mm")
    inner_r = spec.get("marker_inner_radius_mm")
    code_outer_r = spec.get("marker_code_band_outer_radius_mm")
    code_inner_r = spec.get("marker_code_band_inner_radius_mm")

    lines = [
        f"//! Embedded board specification for {spec['name']}.",
        "//!",
        f"//! Generated by `tools/gen_board_spec.py --pitch_mm {pitch} --board_mm {board}`.",
        "//! Do not edit manually.",
        "",
        f"pub const BOARD_NAME: &str = \"{spec['name']}\";",
        f"pub const BOARD_N: usize = {n};",
        f"pub const BOARD_PITCH_MM: f32 = {pitch};",
        f"pub const BOARD_SIZE_MM: [f32; 2] = [{spec['board_size_mm'][0]}, {spec['board_size_mm'][1]}];",
        "",
        "/// Marker geometry in board units (mm).",
        f"pub const MARKER_OUTER_RADIUS_MM: f32 = {outer_r};",
        f"pub const MARKER_INNER_RADIUS_MM: f32 = {inner_r};",
        f"pub const MARKER_CODE_BAND_OUTER_RADIUS_MM: f32 = {code_outer_r};",
        f"pub const MARKER_CODE_BAND_INNER_RADIUS_MM: f32 = {code_inner_r};",
        "",
        "/// Board-coordinate (x, y) in mm for each marker, indexed by codebook ID.",
        f"pub const BOARD_XY_MM: [[f32; 2]; {n}] = [",
    ]

    for m in markers:
        x, y = m["xy_mm"]
        lines.append(f"    [{x:.4f}, {y:.4f}],")

    lines.append("];")
    lines.append("")

    lines.append("/// Axial hex coordinates (q, r) for each marker, indexed by codebook ID.")
    lines.append(f"pub const BOARD_QR: [[i16; 2]; {n}] = [")
    for m in markers:
        lines.append(f"    [{m['q']}, {m['r']}],")
    lines.append("];")
    lines.append("")

    lines.append("/// Look up board coordinates (x, y) in mm for a given marker ID.")
    lines.append("pub fn xy_mm(id: usize) -> Option<[f32; 2]> {")
    lines.append("    BOARD_XY_MM.get(id).copied()")
    lines.append("}")
    lines.append("")
    lines.append("/// Number of markers on the board.")
    lines.append("pub fn n_markers() -> usize {")
    lines.append("    BOARD_N")
    lines.append("}")
    lines.append("")
    lines.append("/// Board name.")
    lines.append("pub fn board_name() -> &'static str {")
    lines.append("    BOARD_NAME")
    lines.append("}")
    lines.append("")
    lines.append("/// Marker outer radius in board units (mm).")
    lines.append("pub fn marker_outer_radius_mm() -> f32 {")
    lines.append("    MARKER_OUTER_RADIUS_MM")
    lines.append("}")
    lines.append("")

    path.parent.mkdir(parents=True, exist_ok=True)
    with open(path, "w") as f:
        f.write("\n".join(lines))
    print(f"Rust module written to {path} ({n} markers)")


def main():
    parser = argparse.ArgumentParser(description="Generate board specification")
    parser.add_argument("--pitch_mm", type=float, default=8.0)
    parser.add_argument("--board_mm", type=float, default=200.0)
    parser.add_argument(
        "--json_out",
        type=str,
        default="tools/board/board_spec.json",
    )
    parser.add_argument(
        "--rust_out",
        type=str,
        default="crates/ringgrid-core/src/board_spec.rs",
    )
    args = parser.parse_args()

    lattice = generate_hex_lattice(args.board_mm, args.pitch_mm)
    n = len(lattice)
    name = f"ringgrid_{int(args.board_mm)}mm_hex"
    marker_outer_radius = args.pitch_mm * 0.6
    marker_inner_radius = args.pitch_mm * 0.4
    marker_code_band_outer_radius = args.pitch_mm * 0.58
    marker_code_band_inner_radius = args.pitch_mm * 0.42

    spec = {
        "name": name,
        "board_size_mm": [args.board_mm, args.board_mm],
        "pitch_mm": args.pitch_mm,
        "origin_mm": [0.0, 0.0],
        "marker_outer_radius_mm": marker_outer_radius,
        "marker_inner_radius_mm": marker_inner_radius,
        "marker_code_band_outer_radius_mm": marker_code_band_outer_radius,
        "marker_code_band_inner_radius_mm": marker_code_band_inner_radius,
        "n_markers": n,
        "markers": [
            {"id": i, "q": q, "r": r, "xy_mm": [round(x, 4), round(y, 4)]}
            for i, (q, r, x, y) in enumerate(lattice)
        ],
    }

    write_json(Path(args.json_out), spec)
    write_rust(Path(args.rust_out), spec)
    print(f"\nBoard: {name}, {n} markers, pitch={args.pitch_mm}mm")


if __name__ == "__main__":
    main()
